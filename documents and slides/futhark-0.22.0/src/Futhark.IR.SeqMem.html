<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-6"></span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Futhark.IR.SeqMem</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier">SeqMem</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Simplification</span></span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Futhark.IR.SeqMem.html#simplifyProg"><span class="hs-identifier">simplifyProg</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Futhark.IR.SeqMem.html#simpleSeqMem"><span class="hs-identifier">simpleSeqMem</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Module re-exports</span></span><span>
</span><span id="line-15"></span><span>    </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html"><span class="hs-identifier">Futhark.IR.Mem</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-16"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span class="hs-keyword">where</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Futhark.Analysis.PrimExp.Convert.html"><span class="hs-identifier">Futhark.Analysis.PrimExp.Convert</span></a></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html"><span class="hs-identifier">Futhark.IR.Mem</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.Simplify.html"><span class="hs-identifier">Futhark.IR.Mem.Simplify</span></a></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Futhark.IR.TypeCheck.html"><span class="hs-identifier">Futhark.IR.TypeCheck</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TC</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Futhark.Optimise.Simplify.Engine.html"><span class="hs-identifier">Futhark.Optimise.Simplify.Engine</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Engine</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Futhark.Pass.html"><span class="hs-identifier">Futhark.Pass</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Futhark.Pass.ExplicitAllocations.html"><span class="hs-identifier">Futhark.Pass.ExplicitAllocations</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.Builder.html#BuilderOps"><span class="hs-identifier">BuilderOps</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Futhark.Pass.ExplicitAllocations.html#mkLetNamesB%27"><span class="hs-identifier">mkLetNamesB'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Futhark.Pass.ExplicitAllocations.html#mkLetNamesB%27%27"><span class="hs-identifier">mkLetNamesB''</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">data</span><span> </span><span id="SeqMem"><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-var">SeqMem</span></a></span></span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.IR.Rep.html#RepTypes"><span class="hs-identifier hs-type">RepTypes</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="LetDec"><span class="annot"><a href="Futhark.IR.Rep.html#LetDec"><span class="hs-identifier hs-var">LetDec</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#LetDecMem"><span class="hs-identifier hs-type">LetDecMem</span></a></span><span>
</span><span id="line-31"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="FParamInfo"><span class="annot"><a href="Futhark.IR.Rep.html#FParamInfo"><span class="hs-identifier hs-var">FParamInfo</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#FParamMem"><span class="hs-identifier hs-type">FParamMem</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="LParamInfo"><span class="annot"><a href="Futhark.IR.Rep.html#LParamInfo"><span class="hs-identifier hs-var">LParamInfo</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#LParamMem"><span class="hs-identifier hs-type">LParamMem</span></a></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="RetType"><span class="annot"><a href="Futhark.IR.Rep.html#RetType"><span class="hs-identifier hs-var">RetType</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#RetTypeMem"><span class="hs-identifier hs-type">RetTypeMem</span></a></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="BranchType"><span class="annot"><a href="Futhark.IR.Rep.html#BranchType"><span class="hs-identifier hs-var">BranchType</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#BranchTypeMem"><span class="hs-identifier hs-type">BranchTypeMem</span></a></span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-keyword">type</span><span> </span><span id="Op"><span class="annot"><a href="Futhark.IR.Rep.html#Op"><span class="hs-identifier hs-var">Op</span></a></span></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Futhark.IR.Mem.html#MemOp"><span class="hs-identifier hs-type">MemOp</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.IR.Prop.html#ASTRep"><span class="hs-identifier hs-type">ASTRep</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-38"></span><span>  </span><span id="local-6989586621684409877"><span class="annot"><span class="annottext">expTypesFromPat :: forall (m :: * -&gt; *).
(HasScope SeqMem m, Monad m) =&gt;
Pat SeqMem -&gt; m [BranchType SeqMem]
</span><a href="Futhark.IR.Prop.html#expTypesFromPat"><span class="hs-identifier hs-var hs-var hs-var hs-var">expTypesFromPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BranchTypeMem] -&gt; m [BranchTypeMem]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([BranchTypeMem] -&gt; m [BranchTypeMem])
-&gt; (PatT LetDecMem -&gt; [BranchTypeMem])
-&gt; PatT LetDecMem
-&gt; m [BranchTypeMem]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((VName, BranchTypeMem) -&gt; BranchTypeMem)
-&gt; [(VName, BranchTypeMem)] -&gt; [BranchTypeMem]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(VName, BranchTypeMem) -&gt; BranchTypeMem
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">([(VName, BranchTypeMem)] -&gt; [BranchTypeMem])
-&gt; (PatT LetDecMem -&gt; [(VName, BranchTypeMem)])
-&gt; PatT LetDecMem
-&gt; [BranchTypeMem]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">PatT LetDecMem -&gt; [(VName, BranchTypeMem)]
</span><a href="Futhark.IR.Mem.html#bodyReturnsFromPat"><span class="hs-identifier hs-var">bodyReturnsFromPat</span></a></span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621684409852"><span class="annot"><a href="Futhark.IR.Pretty.html#PrettyRep"><span class="hs-identifier hs-type">PrettyRep</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span></span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.IR.TypeCheck.html#CheckableOp"><span class="hs-identifier hs-type">TC.CheckableOp</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-43"></span><span>  </span><span id="local-6989586621684409796"><span class="annot"><span class="annottext">checkOp :: OpWithAliases (Op SeqMem) -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#checkOp"><span class="hs-identifier hs-var hs-var hs-var hs-var">checkOp</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.IR.Mem.html#Alloc"><span class="hs-identifier hs-type">Alloc</span></a></span><span> </span><span id="local-6989586621684409793"><span class="annot"><span class="annottext">SubExp
</span><a href="#local-6989586621684409793"><span class="hs-identifier hs-var">size</span></a></span></span><span> </span><span class="annot"><span class="annottext">Space
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><span class="annottext">[TypeBase (ShapeBase SubExp) NoUniqueness]
-&gt; SubExp -&gt; TypeM SeqMem ()
forall rep.
Checkable rep =&gt;
[TypeBase (ShapeBase SubExp) NoUniqueness]
-&gt; SubExp -&gt; TypeM rep ()
</span><a href="Futhark.IR.TypeCheck.html#require"><span class="hs-identifier hs-var">TC.require</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">PrimType -&gt; TypeBase (ShapeBase SubExp) NoUniqueness
forall shape u. PrimType -&gt; TypeBase shape u
</span><a href="Futhark.IR.Syntax.Core.html#Prim"><span class="hs-identifier hs-var">Prim</span></a></span><span> </span><span class="annot"><span class="annottext">PrimType
</span><a href="Futhark.IR.Prop.Types.html#int64"><span class="hs-identifier hs-var">int64</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">SubExp
</span><a href="#local-6989586621684409793"><span class="hs-identifier hs-var">size</span></a></span><span>
</span><span id="line-45"></span><span>  </span><span class="annot"><a href="Futhark.IR.TypeCheck.html#checkOp"><span class="hs-identifier hs-var">checkOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.IR.Mem.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><span class="annottext">() -&gt; TypeM SeqMem ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621684409778"><span id="local-6989586621684409780"><span class="annot"><a href="Futhark.IR.TypeCheck.html#Checkable"><span class="hs-identifier hs-type">TC.Checkable</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-49"></span><span>  </span><span id="local-6989586621684409763"><span class="annot"><span class="annottext">checkFParamDec :: VName -&gt; FParamInfo SeqMem -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#checkFParamDec"><span class="hs-identifier hs-var hs-var hs-var hs-var">checkFParamDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VName -&gt; FParamInfo SeqMem -&gt; TypeM SeqMem ()
forall rep u.
Checkable rep =&gt;
VName -&gt; MemInfo SubExp u MemBind -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#checkMemInfo"><span class="hs-identifier hs-var">checkMemInfo</span></a></span><span>
</span><span id="line-50"></span><span>  </span><span id="local-6989586621684409759"><span class="annot"><span class="annottext">checkLParamDec :: VName -&gt; LParamInfo SeqMem -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#checkLParamDec"><span class="hs-identifier hs-var hs-var hs-var hs-var">checkLParamDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VName -&gt; LParamInfo SeqMem -&gt; TypeM SeqMem ()
forall rep u.
Checkable rep =&gt;
VName -&gt; MemInfo SubExp u MemBind -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#checkMemInfo"><span class="hs-identifier hs-var">checkMemInfo</span></a></span><span>
</span><span id="line-51"></span><span>  </span><span id="local-6989586621684409756"><span class="annot"><span class="annottext">checkLetBoundDec :: VName -&gt; LetDec SeqMem -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#checkLetBoundDec"><span class="hs-identifier hs-var hs-var hs-var hs-var">checkLetBoundDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VName -&gt; LetDec SeqMem -&gt; TypeM SeqMem ()
forall rep u.
Checkable rep =&gt;
VName -&gt; MemInfo SubExp u MemBind -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#checkMemInfo"><span class="hs-identifier hs-var">checkMemInfo</span></a></span><span>
</span><span id="line-52"></span><span>  </span><span id="local-6989586621684409745"><span class="annot"><span class="annottext">checkRetType :: [RetType SeqMem] -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#checkRetType"><span class="hs-identifier hs-var hs-var hs-var hs-var">checkRetType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(RetTypeMem -&gt; TypeM SeqMem ()) -&gt; [RetTypeMem] -&gt; TypeM SeqMem ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeBase (ShapeBase (Ext SubExp)) Uniqueness -&gt; TypeM SeqMem ()
forall rep u.
Checkable rep =&gt;
TypeBase (ShapeBase (Ext SubExp)) u -&gt; TypeM rep ()
</span><a href="Futhark.IR.TypeCheck.html#checkExtType"><span class="hs-identifier hs-var">TC.checkExtType</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeBase (ShapeBase (Ext SubExp)) Uniqueness -&gt; TypeM SeqMem ())
-&gt; (RetTypeMem -&gt; TypeBase (ShapeBase (Ext SubExp)) Uniqueness)
-&gt; RetTypeMem
-&gt; TypeM SeqMem ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">RetTypeMem -&gt; TypeBase (ShapeBase (Ext SubExp)) Uniqueness
forall t.
DeclExtTyped t =&gt;
t -&gt; TypeBase (ShapeBase (Ext SubExp)) Uniqueness
</span><a href="Futhark.IR.Prop.Types.html#declExtTypeOf"><span class="hs-identifier hs-var">declExtTypeOf</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span>  </span><span id="local-6989586621684409737"><span class="annot"><span class="annottext">primFParam :: VName -&gt; PrimType -&gt; TypeM SeqMem (FParam (Aliases SeqMem))
</span><a href="Futhark.IR.TypeCheck.html#primFParam"><span class="hs-identifier hs-var hs-var hs-var hs-var">primFParam</span></a></span></span><span> </span><span id="local-6989586621684409735"><span class="annot"><span class="annottext">VName
</span><a href="#local-6989586621684409735"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621684409734"><span class="annot"><span class="annottext">PrimType
</span><a href="#local-6989586621684409734"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Param FParamMem -&gt; TypeM SeqMem (Param FParamMem)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Param FParamMem -&gt; TypeM SeqMem (Param FParamMem))
-&gt; Param FParamMem -&gt; TypeM SeqMem (Param FParamMem)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Attrs -&gt; VName -&gt; FParamMem -&gt; Param FParamMem
forall dec. Attrs -&gt; VName -&gt; dec -&gt; Param dec
</span><a href="Futhark.IR.Syntax.Core.html#Param"><span class="hs-identifier hs-var">Param</span></a></span><span> </span><span class="annot"><span class="annottext">Attrs
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">VName
</span><a href="#local-6989586621684409735"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PrimType -&gt; FParamMem
forall d u ret. PrimType -&gt; MemInfo d u ret
</span><a href="Futhark.IR.Mem.html#MemPrim"><span class="hs-identifier hs-var">MemPrim</span></a></span><span> </span><span class="annot"><span class="annottext">PrimType
</span><a href="#local-6989586621684409734"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span>  </span><span id="local-6989586621684409720"><span class="annot"><span class="annottext">matchPat :: Pat (Aliases SeqMem) -&gt; Exp (Aliases SeqMem) -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#matchPat"><span class="hs-identifier hs-var hs-var hs-var hs-var">matchPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (Aliases SeqMem) -&gt; Exp (Aliases SeqMem) -&gt; TypeM SeqMem ()
forall rep inner.
(Mem rep inner, LetDec rep ~ LetDecMem, Checkable rep) =&gt;
Pat (Aliases rep) -&gt; Exp (Aliases rep) -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#matchPatToExp"><span class="hs-identifier hs-var">matchPatToExp</span></a></span><span>
</span><span id="line-55"></span><span>  </span><span id="local-6989586621684409708"><span class="annot"><span class="annottext">matchReturnType :: [RetType SeqMem] -&gt; Result -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#matchReturnType"><span class="hs-identifier hs-var hs-var hs-var hs-var">matchReturnType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[RetType SeqMem] -&gt; Result -&gt; TypeM SeqMem ()
forall rep inner.
(Mem rep inner, Checkable rep) =&gt;
[RetTypeMem] -&gt; Result -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#matchFunctionReturnType"><span class="hs-identifier hs-var">matchFunctionReturnType</span></a></span><span>
</span><span id="line-56"></span><span>  </span><span id="local-6989586621684409696"><span class="annot"><span class="annottext">matchBranchType :: [BranchType SeqMem] -&gt; Body (Aliases SeqMem) -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#matchBranchType"><span class="hs-identifier hs-var hs-var hs-var hs-var">matchBranchType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BranchType SeqMem] -&gt; Body (Aliases SeqMem) -&gt; TypeM SeqMem ()
forall rep inner.
(Mem rep inner, Checkable rep) =&gt;
[BranchTypeMem] -&gt; Body (Aliases rep) -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#matchBranchReturnType"><span class="hs-identifier hs-var">matchBranchReturnType</span></a></span><span>
</span><span id="line-57"></span><span>  </span><span id="local-6989586621684409684"><span class="annot"><span class="annottext">matchLoopResult :: [FParam (Aliases SeqMem)] -&gt; Result -&gt; TypeM SeqMem ()
</span><a href="Futhark.IR.TypeCheck.html#matchLoopResult"><span class="hs-identifier hs-var hs-var hs-var hs-var">matchLoopResult</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FParam (Aliases SeqMem)] -&gt; Result -&gt; TypeM SeqMem ()
forall rep inner.
(Mem rep inner, Checkable rep) =&gt;
[FParam (Aliases rep)] -&gt; Result -&gt; TypeM rep ()
</span><a href="Futhark.IR.Mem.html#matchLoopResultMem"><span class="hs-identifier hs-var">matchLoopResultMem</span></a></span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.Builder.html#BuilderOps"><span class="hs-identifier hs-type">BuilderOps</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-60"></span><span>  </span><span id="local-6989586621684409667"><span class="annot"><span class="annottext">mkExpDecB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ SeqMem) =&gt;
Pat SeqMem -&gt; Exp SeqMem -&gt; m (ExpDec SeqMem)
</span><a href="Futhark.Builder.html#mkExpDecB"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkExpDecB</span></a></span></span><span> </span><span class="annot"><span class="annottext">Pat SeqMem
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Exp SeqMem
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span>  </span><span id="local-6989586621684409660"><span class="annot"><span class="annottext">mkBodyB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ SeqMem) =&gt;
Stms SeqMem -&gt; Result -&gt; m (Body SeqMem)
</span><a href="Futhark.Builder.html#mkBodyB"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkBodyB</span></a></span></span><span> </span><span id="local-6989586621684409658"><span class="annot"><span class="annottext">Stms SeqMem
</span><a href="#local-6989586621684409658"><span class="hs-identifier hs-var">stms</span></a></span></span><span> </span><span id="local-6989586621684409657"><span class="annot"><span class="annottext">Result
</span><a href="#local-6989586621684409657"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Body SeqMem -&gt; m (Body SeqMem)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Body SeqMem -&gt; m (Body SeqMem)) -&gt; Body SeqMem -&gt; m (Body SeqMem)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BodyDec SeqMem -&gt; Stms SeqMem -&gt; Result -&gt; Body SeqMem
forall rep. BodyDec rep -&gt; Stms rep -&gt; Result -&gt; BodyT rep
</span><a href="Futhark.IR.Syntax.html#Body"><span class="hs-identifier hs-var">Body</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Stms SeqMem
</span><a href="#local-6989586621684409658"><span class="hs-identifier hs-var">stms</span></a></span><span> </span><span class="annot"><span class="annottext">Result
</span><a href="#local-6989586621684409657"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-62"></span><span>  </span><span id="local-6989586621684409637"><span class="annot"><span class="annottext">mkLetNamesB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ SeqMem) =&gt;
[VName] -&gt; Exp SeqMem -&gt; m (Stm SeqMem)
</span><a href="Futhark.Builder.html#mkLetNamesB"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkLetNamesB</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ExpDec (Rep m) -&gt; [VName] -&gt; Exp (Rep m) -&gt; m (Stm (Rep m))
forall (m :: * -&gt; *) inner.
(LetDec (Rep m) ~ LetDecMem, Mem (Rep m) inner, MonadBuilder m,
 ExpDec (Rep m) ~ ()) =&gt;
ExpDec (Rep m) -&gt; [VName] -&gt; Exp (Rep m) -&gt; m (Stm (Rep m))
</span><a href="Futhark.Pass.ExplicitAllocations.html#mkLetNamesB%27"><span class="hs-identifier hs-var">mkLetNamesB'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.IR.Traversals.html#TraverseOpStms"><span class="hs-identifier hs-type">TraverseOpStms</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-65"></span><span>  </span><span id="local-6989586621684409628"><span class="annot"><span class="annottext">traverseOpStms :: forall (m :: * -&gt; *).
Monad m =&gt;
OpStmsTraverser m (Op SeqMem) SeqMem
</span><a href="Futhark.IR.Traversals.html#traverseOpStms"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverseOpStms</span></a></span></span><span> </span><span class="annot"><span class="annottext">Scope SeqMem -&gt; Stms SeqMem -&gt; m (Stms SeqMem)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Op SeqMem -&gt; m (Op SeqMem)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.Builder.html#BuilderOps"><span class="hs-identifier hs-type">BuilderOps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.Optimise.Simplify.Rep.html#Wise"><span class="hs-identifier hs-type">Engine.Wise</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-68"></span><span>  </span><span id="local-6989586621684409612"><span class="annot"><span class="annottext">mkExpDecB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ Wise SeqMem) =&gt;
Pat (Wise SeqMem) -&gt; Exp (Wise SeqMem) -&gt; m (ExpDec (Wise SeqMem))
</span><a href="#local-6989586621684409612"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkExpDecB</span></a></span></span><span> </span><span id="local-6989586621684409611"><span class="annot"><span class="annottext">Pat (Wise SeqMem)
</span><a href="#local-6989586621684409611"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621684409610"><span class="annot"><span class="annottext">Exp (Wise SeqMem)
</span><a href="#local-6989586621684409610"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ExpWisdom, ()) -&gt; m (ExpWisdom, ())
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((ExpWisdom, ()) -&gt; m (ExpWisdom, ()))
-&gt; (ExpWisdom, ()) -&gt; m (ExpWisdom, ())
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pat (Wise SeqMem)
-&gt; ExpDec SeqMem -&gt; Exp (Wise SeqMem) -&gt; ExpDec (Wise SeqMem)
forall rep.
(ASTRep rep, CanBeWise (Op rep)) =&gt;
Pat (Wise rep) -&gt; ExpDec rep -&gt; Exp (Wise rep) -&gt; ExpDec (Wise rep)
</span><a href="Futhark.Optimise.Simplify.Rep.html#mkWiseExpDec"><span class="hs-identifier hs-var">Engine.mkWiseExpDec</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (Wise SeqMem)
</span><a href="#local-6989586621684409611"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Exp (Wise SeqMem)
</span><a href="#local-6989586621684409610"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-69"></span><span>  </span><span id="local-6989586621684409601"><span class="annot"><span class="annottext">mkBodyB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ Wise SeqMem) =&gt;
Stms (Wise SeqMem) -&gt; Result -&gt; m (Body (Wise SeqMem))
</span><a href="#local-6989586621684409601"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkBodyB</span></a></span></span><span> </span><span id="local-6989586621684409600"><span class="annot"><span class="annottext">Stms (Wise SeqMem)
</span><a href="#local-6989586621684409600"><span class="hs-identifier hs-var">stms</span></a></span></span><span> </span><span id="local-6989586621684409599"><span class="annot"><span class="annottext">Result
</span><a href="#local-6989586621684409599"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Body (Wise SeqMem) -&gt; m (Body (Wise SeqMem))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Body (Wise SeqMem) -&gt; m (Body (Wise SeqMem)))
-&gt; Body (Wise SeqMem) -&gt; m (Body (Wise SeqMem))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">BodyDec SeqMem
-&gt; Stms (Wise SeqMem) -&gt; Result -&gt; Body (Wise SeqMem)
forall rep.
(ASTRep rep, CanBeWise (Op rep)) =&gt;
BodyDec rep -&gt; Stms (Wise rep) -&gt; Result -&gt; Body (Wise rep)
</span><a href="Futhark.Optimise.Simplify.Rep.html#mkWiseBody"><span class="hs-identifier hs-var">Engine.mkWiseBody</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Stms (Wise SeqMem)
</span><a href="#local-6989586621684409600"><span class="hs-identifier hs-var">stms</span></a></span><span> </span><span class="annot"><span class="annottext">Result
</span><a href="#local-6989586621684409599"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-70"></span><span>  </span><span id="local-6989586621684409568"><span class="annot"><span class="annottext">mkLetNamesB :: forall (m :: * -&gt; *).
(MonadBuilder m, Rep m ~ Wise SeqMem) =&gt;
[VName] -&gt; Exp (Wise SeqMem) -&gt; m (Stm (Wise SeqMem))
</span><a href="#local-6989586621684409568"><span class="hs-identifier hs-var hs-var hs-var hs-var">mkLetNamesB</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VName] -&gt; Exp (Wise SeqMem) -&gt; m (Stm (Wise SeqMem))
forall rep inner (m :: * -&gt; *).
(BuilderOps rep, Mem rep inner, LetDec rep ~ LetDecMem,
 OpReturns (OpWithWisdom inner), ExpDec rep ~ (), Rep m ~ Wise rep,
 HasScope (Wise rep) m, MonadBuilder m, CanBeWise inner) =&gt;
[VName] -&gt; Exp (Wise rep) -&gt; m (Stm (Wise rep))
</span><a href="Futhark.Pass.ExplicitAllocations.html#mkLetNamesB%27%27"><span class="hs-identifier hs-var">mkLetNamesB''</span></a></span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Futhark.IR.Traversals.html#TraverseOpStms"><span class="hs-identifier hs-type">TraverseOpStms</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.Optimise.Simplify.Rep.html#Wise"><span class="hs-identifier hs-type">Engine.Wise</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-73"></span><span>  </span><span id="local-6989586621684409563"><span class="annot"><span class="annottext">traverseOpStms :: forall (m :: * -&gt; *).
Monad m =&gt;
OpStmsTraverser m (Op (Wise SeqMem)) (Wise SeqMem)
</span><a href="#local-6989586621684409563"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverseOpStms</span></a></span></span><span> </span><span class="annot"><span class="annottext">Scope (Wise SeqMem) -&gt; Stms (Wise SeqMem) -&gt; m (Stms (Wise SeqMem))
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Op (Wise SeqMem) -&gt; m (Op (Wise SeqMem))
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span class="annot"><a href="Futhark.IR.SeqMem.html#simplifyProg"><span class="hs-identifier hs-type">simplifyProg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Futhark.IR.Syntax.html#Prog"><span class="hs-identifier hs-type">Prog</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Futhark.Pass.html#PassM"><span class="hs-identifier hs-type">PassM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Futhark.IR.Syntax.html#Prog"><span class="hs-identifier hs-type">Prog</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-76"></span><span id="simplifyProg"><span class="annot"><span class="annottext">simplifyProg :: Prog SeqMem -&gt; PassM (Prog SeqMem)
</span><a href="Futhark.IR.SeqMem.html#simplifyProg"><span class="hs-identifier hs-var hs-var">simplifyProg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SimpleOps SeqMem -&gt; Prog SeqMem -&gt; PassM (Prog SeqMem)
forall rep inner.
SimplifyMemory rep inner =&gt;
SimpleOps rep -&gt; Prog rep -&gt; PassM (Prog rep)
</span><a href="Futhark.IR.Mem.Simplify.html#simplifyProgGeneric"><span class="hs-identifier hs-var">simplifyProgGeneric</span></a></span><span> </span><span class="annot"><span class="annottext">SimpleOps SeqMem
</span><a href="Futhark.IR.SeqMem.html#simpleSeqMem"><span class="hs-identifier hs-var">simpleSeqMem</span></a></span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="annot"><a href="Futhark.IR.SeqMem.html#simpleSeqMem"><span class="hs-identifier hs-type">simpleSeqMem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Futhark.Optimise.Simplify.Engine.html#SimpleOps"><span class="hs-identifier hs-type">Engine.SimpleOps</span></a></span><span> </span><span class="annot"><a href="Futhark.IR.SeqMem.html#SeqMem"><span class="hs-identifier hs-type">SeqMem</span></a></span><span>
</span><span id="line-79"></span><span id="simpleSeqMem"><span class="annot"><span class="annottext">simpleSeqMem :: SimpleOps SeqMem
</span><a href="Futhark.IR.SeqMem.html#simpleSeqMem"><span class="hs-identifier hs-var hs-var">simpleSeqMem</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-80"></span><span>  </span><span class="annot"><span class="annottext">(OpWithWisdom () -&gt; UsageTable)
-&gt; SimplifyOp SeqMem (OpWithWisdom ()) -&gt; SimpleOps SeqMem
forall rep inner.
SimplifyMemory rep inner =&gt;
(OpWithWisdom inner -&gt; UsageTable)
-&gt; SimplifyOp rep (OpWithWisdom inner) -&gt; SimpleOps rep
</span><a href="Futhark.IR.Mem.Simplify.html#simpleGeneric"><span class="hs-identifier hs-var">simpleGeneric</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">UsageTable -&gt; () -&gt; UsageTable
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">UsageTable
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(SimplifyOp SeqMem (OpWithWisdom ()) -&gt; SimpleOps SeqMem)
-&gt; SimplifyOp SeqMem (OpWithWisdom ()) -&gt; SimpleOps SeqMem
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">SimpleM SeqMem ((), Stms (Wise SeqMem))
-&gt; () -&gt; SimpleM SeqMem ((), Stms (Wise SeqMem))
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(SimpleM SeqMem ((), Stms (Wise SeqMem))
 -&gt; () -&gt; SimpleM SeqMem ((), Stms (Wise SeqMem)))
-&gt; SimpleM SeqMem ((), Stms (Wise SeqMem))
-&gt; ()
-&gt; SimpleM SeqMem ((), Stms (Wise SeqMem))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((), Stms (Wise SeqMem)) -&gt; SimpleM SeqMem ((), Stms (Wise SeqMem))
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Stms (Wise SeqMem)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span class="hs-special">)</span><span>
</span><span id="line-81"></span></pre></body></html>